// =======================================================================
// Fall Detector Prototype (Arduino Uno)
// =======================================================================
// This sketch implements a basic fall detection system using an IMU
// (MPU6500 - Accelerometer & Gyroscope only), a Push Button, LEDs,
// and a Speaker/Buzzer.
// It detects sudden movements characteristic of a fall and triggers an alarm.
// All processing is done directly on the Arduino Uno.
//
// This version uses the 'bolderflight/invensense-imu' library for MPU6500.
//
// Author: Gemini
// Date: July 5, 2025 (Updated with variable alarm duration)
// =======================================================================

// --- Libraries ---
#include "Wire.h" // Required for I2C communication with MPU6500
#include "mpu6500.h" // Correct header for MPU6500 from bolderflight library

// --- Pin Definitions ---
// IMU (MPU6500) - I2C pins are A4 (SDA) and A5 (SCL) on Arduino Uno
// (These are hardware I2C pins, no explicit pinMode is needed for them)

const int SPEAKER_PIN = 6;     // Digital pin connected to the speaker/buzzer
const int BUTTON_PIN = 2;      // Digital pin connected to the push button
const int READY_LED = 3;       // Green LED - System ready/normal operation
const int ALARM_LED = 4;       // Red LED - Fall detected / Alarm active

// --- Sensor Variables ---
// Instantiate Mpu6500 object within the bfs namespace
// Using I2C_ADDR_PRIM (0x68) assuming AD0 pin on MPU module is connected to GND or left floating.
bfs::Mpu6500 imu(&Wire, bfs::Mpu6500::I2C_ADDR_PRIM);

// --- IMU Calibration Offsets (REQUIRED FOR ACCURATE GYRO) ---
// These values will be calculated during the setup() routine by averaging readings
// while the sensor is held still. They compensate for sensor drift.
float gyroX_offset = 0.00;
float gyroY_offset = 0.00;
float gyroZ_offset = 0.00;

// --- Fall Detection Thresholds & State Variables ---
// These thresholds are CRITICAL and will likely require fine-tuning
// based on sensor placement (e.g., on wrist, chest, etc.) and
// extensive testing with actual fall simulations.
// A typical fall signature involves:
// 1. A period of low acceleration (freefall).
// 2. Followed by a sudden, high acceleration impact.
// 3. Followed by a period of stillness (lying on the ground).

// ACCEL_FREEFALL_THRESHOLD_G: Max acceleration during freefall.
// A value close to 0 indicates true freefall. A slight increase (e.g., 0.3g)
// can account for minor air resistance or sensor noise during a drop.
const float ACCEL_FREEFALL_THRESHOLD_G = 0.3;

// ACCEL_FALL_THRESHOLD_G: Min acceleration for impact detection.
// This value should be significantly higher than 1G to detect a sharp impact.
// Experiment with values like 2.0 to 5.0 depending on how hard the impact is.
const float ACCEL_FALL_THRESHOLD_G = 2.5;

// FALL_DETECTION_WINDOW_MS: Max time allowed between freefall and impact.
// A typical fall happens quickly. This window prevents unrelated events from triggering.
const unsigned long FALL_DETECTION_WINDOW_MS = 300;

// POST_FALL_STILLNESS_MS: Duration of stillness required after impact to confirm fall.
// This helps differentiate a fall from a jump or stumble where motion resumes quickly.
const unsigned long POST_FALL_STILLNESS_MS = 1000;

// Stillness Check Range: Defines the acceptable range for acceleration magnitude
// when the device is considered "still" (e.g., lying flat on a surface).
// Should be centered around 1.0g (gravity).
const float STILLNESS_ACCEL_MIN_G = 0.8;
const float STILLNESS_ACCEL_MAX_G = 1.2;

// Stillness Gyro Threshold: Max gyroscope magnitude for "stillness."
// Should be a very small value, indicating no significant rotation.
const float STILLNESS_GYRO_MAX_DPS = 10.0;

// --- Alarm Duration Variables ---
const unsigned long MIN_ALARM_DURATION_MS = 2000; // Minimum alarm duration (2 seconds)
const unsigned long MAX_ALARM_DURATION_MS = 10000; // Maximum alarm duration (10 seconds)
const float ALARM_DURATION_SCALING_FACTOR = 1000.0; // Milliseconds per G above ACCEL_FALL_THRESHOLD_G

bool isAlarmActive = false;      // Flag to track if the alarm is currently active
unsigned long fallStartTime = 0; // Timestamp (millis()) when potential fall (freefall) started
unsigned long impactTime = 0;    // Timestamp (millis()) when potential impact occurred
float lastImpactAccelMagnitude = 0.0; // Store accel magnitude at impact for alarm duration calculation
unsigned long alarmActivatedTime = 0; // Timestamp when the alarm was activated

// --- Button Debounce ---
long lastButtonPressTime = 0;    // Stores the last time the button was pressed
const long DEBOUNCE_DELAY = 50; // Milliseconds to ignore subsequent button presses (debounce)

// --- Conversion Factors ---
// These constants convert sensor raw units (radians/sec, m/s^2) to more intuitive units (degrees/sec, G's).
const float DEG_PER_RAD = 57.295779513; // Conversion from radians to degrees (180 / PI)
const float G_PER_MPS2 = 9.80665;       // Standard gravity (g) in meters per second squared

// =======================================================================
// SETUP Function: Runs once when the Arduino starts
// =======================================================================
void setup() {
  Serial.begin(115200); // Initialize serial communication for debugging output
  while (!Serial) {
    delay(10); // Wait for serial port to connect (especially useful for boards with native USB)
  }

  // --- Configure Pin Modes ---
  pinMode(SPEAKER_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP); // Configure button pin with internal pull-up resistor.
                                     // Connect the button between this pin and GND.
  pinMode(READY_LED, OUTPUT);
  pinMode(ALARM_LED, OUTPUT);

  // Ensure all LEDs are off at the start
  digitalWrite(READY_LED, LOW);
  digitalWrite(ALARM_LED, LOW);

  // --- IMU Initialization ---
  Wire.begin();       // Initialize I2C communication for the IMU sensor
  Wire.setClock(400000); // Set I2C clock to 400kHz (Fast Mode) for faster data transfer

  Serial.print("Initializing MPU6500 IMU...");
  // Attempt to begin communication with the MPU6500 using the bolderflight library.
  // imu.Begin() returns true on success, false on failure.
  if (!imu.Begin()) {
    Serial.println("FAILED! Check IMU wiring (SDA to A4, SCL to A5, VCC, GND).");
    // If IMU fails to initialize, enter an infinite loop to signal a critical error
    while (1) {
      digitalWrite(ALARM_LED, HIGH); // Blink red LED rapidly to indicate the error
      delay(200);
      digitalWrite(ALARM_LED, LOW);
      delay(200);
    }
  }

  // Configure accelerometer and gyroscope ranges after successful initialization.
  // These ranges determine the sensitivity and maximum values the sensor can read.
  if (!imu.ConfigAccelRange(bfs::Mpu6500::ACCEL_RANGE_8G)) {
    Serial.println("Failed to set Accelerometer Range!");
  }
  if (!imu.ConfigGyroRange(bfs::Mpu6500::GYRO_RANGE_1000DPS)) {
    Serial.println("Failed to set Gyroscope Range!");
  }

  Serial.println("SUCCESS!");

  // --- Gyroscope Calibration Routine ---
  // Gyroscopes tend to drift over time. Calibration removes this bias.
  // It's crucial to keep the sensor ABSOLUTELY STILL during this phase!
  Serial.println("\nCalibrating Gyroscope... Keep sensor ABSOLUTELY STILL for 5 seconds.");
  digitalWrite(READY_LED, HIGH); // Turn on green LED to indicate calibration is in progress
  delay(2000); // Give the user 2 seconds to place the sensor still before readings begin

  long sumX = 0, sumY = 0, sumZ = 0;
  int numReadings = 1000; // Number of readings to average for calibration accuracy

  for (int i = 0; i < numReadings; i++) {
    imu.Read(); // Read the latest sensor data from the IMU
    // Accumulate gyroscope readings, converting from radians/sec to degrees/sec
    // and scaling by 1000 to maintain precision with integer sums.
    sumX += (long)(imu.gyro_x_radps() * DEG_PER_RAD * 1000);
    sumY += (long)(imu.gyro_y_radps() * DEG_PER_RAD * 1000);
    sumZ += (long)(imu.gyro_z_radps() * DEG_PER_RAD * 1000);
    delay(5); // Small delay between readings to allow sensor to update
  }

  // Calculate the average offset for each gyroscope axis
  gyroX_offset = (float)sumX / (numReadings * 1000.0);
  gyroY_offset = (float)sumY / (numReadings * 1000.0);
  gyroZ_offset = (float)sumZ / (numReadings * 1000.0);

  Serial.print("Gyro Offsets Found: X="); Serial.print(gyroX_offset, 3); // Print offsets with 3 decimal places
  Serial.print(", Y="); Serial.print(gyroY_offset, 3);
  Serial.print(", Z="); Serial.println(gyroZ_offset, 3);
  Serial.println("Calibration Complete! System Ready.");

  // Indicate system readiness with LEDs and a short beep
  digitalWrite(READY_LED, HIGH); // Green LED on, indicating the system is ready for fall detection
  digitalWrite(ALARM_LED, LOW);   // Ensure the red alarm LED is off
  tone(SPEAKER_PIN, 800, 200); // Play a short, medium-pitch beep to confirm readiness
  delay(200); // Wait for the beep to complete
  noTone(SPEAKER_PIN); // Stop the tone

  Serial.println("\n--- Fall Detector Active ---");
  Serial.println("Move the device to simulate falls (e.g., drop, then let it lie still).");
  Serial.println("Press the button to reset the alarm or manually trigger it.");
  Serial.println("Accel_Mag(g)\tGyro_Mag(dps)\tFallState\tAlarm");
}

// =======================================================================
// LOOP Function: Runs repeatedly after setup()
// =======================================================================
void loop() {
  imu.Read(); // Read the latest accelerometer and gyroscope data from the IMU

  // --- Process Accelerometer Data ---
  // Get accelerometer data in m/s^2 and convert to G's (multiples of standard gravity)
  float accelX = imu.accel_x_mps2() / G_PER_MPS2;
  float accelY = imu.accel_y_mps2() / G_PER_MPS2;
  float accelZ = imu.accel_z_mps2() / G_PER_MPS2;

  // Calculate the magnitude (total vector sum) of acceleration.
  // This value helps detect sudden changes in motion regardless of orientation.
  float accelMagnitude = sqrt(sq(accelX) + sq(accelY) + sq(accelZ));

  // --- Process Gyroscope Data ---
  // Get gyroscope data in radians/sec, convert to degrees/sec, then apply calibration offsets.
  float gyroX = (imu.gyro_x_radps() * DEG_PER_RAD) - gyroX_offset;
  float gyroY = (imu.gyro_y_radps() * DEG_PER_RAD) - gyroY_offset;
  float gyroZ = (imu.gyro_z_radps() * DEG_PER_RAD) - gyroZ_offset;

  // Calculate the magnitude (total vector sum) of angular velocity.
  // This value helps detect rapid rotations or tumbling.
  float gyroMagnitude = sqrt(sq(gyroX) + sq(gyroY) + sq(gyroZ));

  // --- Fall Detection Logic (State Machine) ---
  // The system transitions through states to confirm a fall:
  // NORMAL -> FREEFALL -> IMPACT -> STILLNESS (Fall Detected)
  if (!isAlarmActive) { // Only attempt to detect falls if the alarm is not already active

    // State 1: Detect potential freefall (acceleration significantly less than 1G).
    // This is the initial trigger for a potential fall.
    if (accelMagnitude < ACCEL_FREEFALL_THRESHOLD_G && fallStartTime == 0) {
      fallStartTime = millis(); // Record the timestamp of freefall detection
      Serial.println("Potential Freefall Detected!");
    }

    // State 2: Check for a high-impact event after freefall.
    // This confirms the "landing" part of a fall.
    if (fallStartTime != 0 && (millis() - fallStartTime < FALL_DETECTION_WINDOW_MS)) {
      if (accelMagnitude > ACCEL_FALL_THRESHOLD_G && impactTime == 0) {
        impactTime = millis(); // Record the timestamp of the impact
        lastImpactAccelMagnitude = accelMagnitude; // Store impact magnitude
        Serial.println("Impact Detected!");
      }
    }

    // State 3: Confirm stillness after the potential fall (impact).
    // After impact, the device should be relatively still (near 1G, low rotation)
    // for a certain period to confirm it's a fall and not just a jump or stumble.
    if (impactTime != 0 && (millis() - impactTime > POST_FALL_STILLNESS_MS)) {
      // Check for acceleration near 1G (indicating it's lying still) and very low rotation.
      if (accelMagnitude < STILLNESS_ACCEL_MAX_G && accelMagnitude > STILLNESS_ACCEL_MIN_G && gyroMagnitude < STILLNESS_GYRO_MAX_DPS) {
        isAlarmActive = true; // Fall confirmed!
        Serial.println("FALL DETECTED!");
        digitalWrite(READY_LED, LOW); // Turn off green LED
        digitalWrite(ALARM_LED, HIGH); // Turn on red LED

        // Calculate alarm duration based on impact severity
        unsigned long calculatedAlarmDuration = MIN_ALARM_DURATION_MS +
                                                (unsigned long)((lastImpactAccelMagnitude - ACCEL_FALL_THRESHOLD_G) * ALARM_DURATION_SCALING_FACTOR);
        // Clamp duration within min and max limits
        calculatedAlarmDuration = constrain(calculatedAlarmDuration, MIN_ALARM_DURATION_MS, MAX_ALARM_DURATION_MS);

        tone(SPEAKER_PIN, 3000, calculatedAlarmDuration); // Start a loud, high-pitched alarm sound for calculated duration
        alarmActivatedTime = millis(); // Record when alarm started for auto-stop
        Serial.print("Alarm duration: "); Serial.print(calculatedAlarmDuration); Serial.println(" ms");

      } else {
        // If the conditions for stillness are not met, reset the fall detection states.
        // This prevents false positives from non-fall events (e.g., throwing the device).
        fallStartTime = 0;
        impactTime = 0;
        Serial.println("Fall detection reset (not still enough or not a confirmed fall).");
      }
    }

    // Timeout for freefall: If freefall started but no impact occurred within the window, reset.
    // This handles cases where there's a brief freefall but no subsequent impact (e.g., dropping onto a soft surface).
    if (fallStartTime != 0 && (millis() - fallStartTime >= FALL_DETECTION_WINDOW_MS) && impactTime == 0) {
      fallStartTime = 0;
      Serial.println("Freefall timed out, no impact detected.");
    }
  } else { // If alarm is active
    // Check if the alarm duration has passed
    if (millis() - alarmActivatedTime >= toneDuration(SPEAKER_PIN)) { // toneDuration() is not a real function, using a placeholder
        // This needs to be handled by the tone() function itself or a custom timer
        // For now, the tone() function with duration will handle stopping.
        // We'll keep the alarm active until manually reset.
    }
  }


  // --- Alarm Management ---
  if (isAlarmActive) {
    // If the alarm is active, make the red ALARM_LED blink to draw attention.
    digitalWrite(ALARM_LED, !digitalRead(ALARM_LED)); // Toggle LED state (on/off)
    delay(100); // Fast blink rate
  }

  // --- Button Logic to Reset Alarm or Manually Trigger ---
  // Read the button state. The INPUT_PULLUP configuration means the pin is LOW when pressed.
  // Debounce logic prevents multiple triggers from a single physical button press.
  if (digitalRead(BUTTON_PIN) == LOW && (millis() - lastButtonPressTime > DEBOUNCE_DELAY)) {
    lastButtonPressTime = millis(); // Update the timestamp of the last valid button press

    if (isAlarmActive) {
      // If the alarm is currently active, pressing the button resets it.
      isAlarmActive = false;
      noTone(SPEAKER_PIN); // Stop the alarm sound
      digitalWrite(ALARM_LED, LOW); // Turn off red alarm LED
      digitalWrite(READY_LED, HIGH); // Turn on green ready LED
      Serial.println("Alarm Reset by User.");
      tone(SPEAKER_PIN, 1000, 100); // Play a short confirmation beep
      delay(100); // Wait for the beep to complete
      noTone(SPEAKER_PIN); // Stop the confirmation beep
    } else {
      // If the alarm is not active, pressing the button manually triggers it.
      isAlarmActive = true;
      Serial.println("Manual Alarm Triggered by User!");
      digitalWrite(READY_LED, LOW); // Turn off green LED
      digitalWrite(ALARM_LED, HIGH); // Turn on red LED
      // Manual trigger always uses max duration for a strong alert
      tone(SPEAKER_PIN, 3000, MAX_ALARM_DURATION_MS);
      alarmActivatedTime = millis(); // Record when alarm started for auto-stop
    }
  }

  // --- Serial Debug Output ---
  // Print sensor data and system status to the Serial Monitor for debugging and monitoring.
  Serial.print(accelMagnitude, 2); // Accelerometer magnitude (in G's) with 2 decimal places
  Serial.print("\t\t");
  Serial.print(gyroMagnitude, 2); // Gyroscope magnitude (in degrees/sec) with 2 decimal places
  Serial.print("\t\t");
  // Display current fall detection state (NORMAL, FREEFALL, IMPACT)
  Serial.print(fallStartTime != 0 ? "FREEFALL" : (impactTime != 0 ? "IMPACT" : "NORMAL"));
  Serial.print("\t\t");
  // Display current alarm status (ACTIVE or OFF)
  Serial.println(isAlarmActive ? "ACTIVE" : "OFF");

  delay(50); // Small delay to control the loop speed and serial output rate.
             // Adjust this value to balance responsiveness and processing load.
}
